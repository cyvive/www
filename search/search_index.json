{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"60 Second Overview Why? The modern Information Technology Development Approach is based on Speed, Scale Margin . As a result organizations of all sizes are embracing the Cloud Native approach to designing, building and running applications based on Infrastructure-as-a-Service (IaaS) in combination with operational tools and services such as Continous Integration (CI), Continous Deployment (CD), Containers, and Orchestrators. To execute Cloud Native five layers are required: Infrastructure (Bare Metal / Cloud) Provisioning Runtme Orchestration Management Application Definition / Development This simplistic layering opens a world of choices, when combined with the reality that some tools in one layer work better with specific tools than others, a complex exponential selection process is established. There is a strong market need for simplicity, sanity and control of the n+1 choices available when using Cloud Native architecture. What? Cyvive provides Immutable Change , from the instrastructure through to moment in time understanding of deployed applications. Everything is Immutable. This means your business, or parts of it can be reproduced, moved or upgraded safely. This Immutable Change is provided through two key approaches: Operational Platform Infrastructure-as-a-Service, expects the cloud service provider to deliver infrastructure components that would otherwise exist in an on-premises data center. These components could consist of servers, storage and networking as well as the virtualization layer, which the IaaS provider hosts in its own data center. While they may also provide Platform-as-a-Service (PaaS) offerings such as cloud functions, container execution api's, or even Kubernetes variations. By design, they are not turn-key offerings. Cyvive , however, is. As an operational platform, it directly interfaces with the cloud provider (or Bare Metal) of choice using the provides IaaS interactions to provision an immutable collection of components necessary to run the orchestrator of choice. The default being Kubernetes EcoSystem Cloud Native requires a collection of tools, or an extended ecosystem of services to understand and, unlock and leverage its full potential. Each tool, when selected by companies typically goes through a process, that takes months for an efficient team with multitudes of Proof of Concepts, each potentially causing back to the drawing board moments . The modern company doesn't have the luxury of time to assess, stabilize and incrementally add each component of the Cloud Native ecosystem while guaranteeing stability amongst change management in their Digital Transformation journey. Cyvive takes the best in breed tool for each part of the EcoSystem and manages its lifecycle. Choices are available between Open Source or Propriatory where possible. Such careful selection and management of the Best in Breed Candidates of the EcoSystem unlocks the power of the Orchestrator to perform often significantly beyond its standard capabilities Governance MicroServices are a suite of applications providing a specific function. They are also a key part of Cloud Native architecture, and while there are many benefits to adopting this model over alternatives such as OSIMM / TOSCA. Orchestration Management alone is insufficient and inefficient to managing complex deployments as each has independent release cycles. The defacto approach to MicroServices is to run them within a container, in most situations, even the functions / serverless approach ultimately runs within a container. As such to actually execute the code, open source and propriatory libraries (which are regularly updated) are aggregated into the container, where to comply with security and zero day vulnerability patching must be updated regularly. Ironically, 50 MicroServices are often the tipping point for unmanagable complexity. 50 MicroServices can have a maximum of 1225 interactions, versions, and dependencies between eachother. It is also a realistic expectation that at least one of the Open Source libraries used in each MicroService will need to be updated, tested and validated as production safe. Once every couple of days, or potentially 700 redeploys a month. While the Continous Integration System may validate the code is safe, by nature MicroServices require Continous Deployment / Promotion through environmental complexity to proove they are production stable. MicroServices also have their own independent dependency graph, so actual deployments may not be as simple as replacing a single service in isolation each time. Cyvive , as the Premier MicroService Governance solution, streamlines all complexities through dynamic dependency graphs, an industry standard configuration communication syntax, release management, configuration and version management for MicroServices through to Infrastructure. Any part of your infrastructure can be deployed on-demand, with all relevant dependent services, in any environment. Cloud Agnostic It is no longer a realistic expectation that companies can enhance their technology stack by partnering with a single cloud provider. With the growing multitude of high quality cloud providers, each offering niche tools a multi-cloud strategy is a necessity. Cyvive 's detailed Governance and Operational Capabilities allow rapid movement of workloads between cloud providers at an unprecidented scale. It is now a realistic expectation that every hour your entire company can be migrated between clouds based on lowest instance pricing. Without disruption of service. How? We worked with 3 Universities, and over 35 industry publications to analyse trends and approaches to modelling, scaling, interacting and managing MicroService deployents at diabolical scale. The result is the core configuration language of Cyvive , a direct extension of natural descriptive language used in companies today. We also cross partnered to understand and explore each part of the Cloud Native EcoSystem to architect and craft a well-balanced blend of services capable of supporting over 2,500 nodes with 500 containers each. (Yes, Cyvive has been applied to managing over 1 million containers) We pushed immutability down to the operating system, every machine self registers, and is managed exclusively by Cyvive . There is no human access available to the actual machine. Making Cyvive inaccessible to human error. While Cyvive is orchestrator independent, it has been actively used with Kubernetes since version 1.6.x (March 2017) Finally, we selected Terraform for cloud provider bare metal interactions. Properly tuned, full immutable lifecyle management was possible while leveraging all the important functionalities of major cloud providers. Where? All Major Public Clouds AMD64 / ARM64 Chipsets Bare Metal ( Cyvive creates its own cloud on metal) Cyvive : The Premier Cloud Agnostic Operation Governance Platform","title":"Cyvive"},{"location":"#60-second-overview","text":"","title":"60 Second Overview"},{"location":"#why","text":"The modern Information Technology Development Approach is based on Speed, Scale Margin . As a result organizations of all sizes are embracing the Cloud Native approach to designing, building and running applications based on Infrastructure-as-a-Service (IaaS) in combination with operational tools and services such as Continous Integration (CI), Continous Deployment (CD), Containers, and Orchestrators. To execute Cloud Native five layers are required: Infrastructure (Bare Metal / Cloud) Provisioning Runtme Orchestration Management Application Definition / Development This simplistic layering opens a world of choices, when combined with the reality that some tools in one layer work better with specific tools than others, a complex exponential selection process is established. There is a strong market need for simplicity, sanity and control of the n+1 choices available when using Cloud Native architecture.","title":"Why?"},{"location":"#what","text":"Cyvive provides Immutable Change , from the instrastructure through to moment in time understanding of deployed applications. Everything is Immutable. This means your business, or parts of it can be reproduced, moved or upgraded safely. This Immutable Change is provided through two key approaches:","title":"What?"},{"location":"#operational-platform","text":"Infrastructure-as-a-Service, expects the cloud service provider to deliver infrastructure components that would otherwise exist in an on-premises data center. These components could consist of servers, storage and networking as well as the virtualization layer, which the IaaS provider hosts in its own data center. While they may also provide Platform-as-a-Service (PaaS) offerings such as cloud functions, container execution api's, or even Kubernetes variations. By design, they are not turn-key offerings. Cyvive , however, is. As an operational platform, it directly interfaces with the cloud provider (or Bare Metal) of choice using the provides IaaS interactions to provision an immutable collection of components necessary to run the orchestrator of choice. The default being Kubernetes","title":"Operational Platform"},{"location":"#ecosystem","text":"Cloud Native requires a collection of tools, or an extended ecosystem of services to understand and, unlock and leverage its full potential. Each tool, when selected by companies typically goes through a process, that takes months for an efficient team with multitudes of Proof of Concepts, each potentially causing back to the drawing board moments . The modern company doesn't have the luxury of time to assess, stabilize and incrementally add each component of the Cloud Native ecosystem while guaranteeing stability amongst change management in their Digital Transformation journey. Cyvive takes the best in breed tool for each part of the EcoSystem and manages its lifecycle. Choices are available between Open Source or Propriatory where possible. Such careful selection and management of the Best in Breed Candidates of the EcoSystem unlocks the power of the Orchestrator to perform often significantly beyond its standard capabilities","title":"EcoSystem"},{"location":"#governance","text":"MicroServices are a suite of applications providing a specific function. They are also a key part of Cloud Native architecture, and while there are many benefits to adopting this model over alternatives such as OSIMM / TOSCA. Orchestration Management alone is insufficient and inefficient to managing complex deployments as each has independent release cycles. The defacto approach to MicroServices is to run them within a container, in most situations, even the functions / serverless approach ultimately runs within a container. As such to actually execute the code, open source and propriatory libraries (which are regularly updated) are aggregated into the container, where to comply with security and zero day vulnerability patching must be updated regularly. Ironically, 50 MicroServices are often the tipping point for unmanagable complexity. 50 MicroServices can have a maximum of 1225 interactions, versions, and dependencies between eachother. It is also a realistic expectation that at least one of the Open Source libraries used in each MicroService will need to be updated, tested and validated as production safe. Once every couple of days, or potentially 700 redeploys a month. While the Continous Integration System may validate the code is safe, by nature MicroServices require Continous Deployment / Promotion through environmental complexity to proove they are production stable. MicroServices also have their own independent dependency graph, so actual deployments may not be as simple as replacing a single service in isolation each time. Cyvive , as the Premier MicroService Governance solution, streamlines all complexities through dynamic dependency graphs, an industry standard configuration communication syntax, release management, configuration and version management for MicroServices through to Infrastructure. Any part of your infrastructure can be deployed on-demand, with all relevant dependent services, in any environment.","title":"Governance"},{"location":"#cloud-agnostic","text":"It is no longer a realistic expectation that companies can enhance their technology stack by partnering with a single cloud provider. With the growing multitude of high quality cloud providers, each offering niche tools a multi-cloud strategy is a necessity. Cyvive 's detailed Governance and Operational Capabilities allow rapid movement of workloads between cloud providers at an unprecidented scale. It is now a realistic expectation that every hour your entire company can be migrated between clouds based on lowest instance pricing. Without disruption of service.","title":"Cloud Agnostic"},{"location":"#how","text":"We worked with 3 Universities, and over 35 industry publications to analyse trends and approaches to modelling, scaling, interacting and managing MicroService deployents at diabolical scale. The result is the core configuration language of Cyvive , a direct extension of natural descriptive language used in companies today. We also cross partnered to understand and explore each part of the Cloud Native EcoSystem to architect and craft a well-balanced blend of services capable of supporting over 2,500 nodes with 500 containers each. (Yes, Cyvive has been applied to managing over 1 million containers) We pushed immutability down to the operating system, every machine self registers, and is managed exclusively by Cyvive . There is no human access available to the actual machine. Making Cyvive inaccessible to human error. While Cyvive is orchestrator independent, it has been actively used with Kubernetes since version 1.6.x (March 2017) Finally, we selected Terraform for cloud provider bare metal interactions. Properly tuned, full immutable lifecyle management was possible while leveraging all the important functionalities of major cloud providers.","title":"How?"},{"location":"#where","text":"All Major Public Clouds AMD64 / ARM64 Chipsets Bare Metal ( Cyvive creates its own cloud on metal) Cyvive : The Premier Cloud Agnostic Operation Governance Platform","title":"Where?"},{"location":"ecosystem/","text":"","title":"Understanding"},{"location":"governance/","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Applications / Services / Components / Functions are all descriptors for various complexity and integration levels of code. While each could exist in isolation, more often than not an architectural approach is selected for logical separation of business processes both internal and external. When an architecture is introduced, its necessary for governance to also co-habitiate to ensure that the software solutions within an organization adhere to the defined policies, guidelines, and standards that are defined as a function of the objectives, strategies, and regulations applied in the organization. The challenge lies around development velocity and ironically management of governance itself as companies progress through the technology layers defined in the OSIMM V2 Model . Specifically Layers 4 - 7 where each technological progression results in exponentially exploding the number of managed code assets. Cyvive.io is a Solution Oriented Infrastructure technology capable of operating at Layer 4 - 7 though governance via policy. It is: cloud agnostic container orchestrator independent Don't Repeat Yourself (DRY) Capable of Managing / Deploying entire companies / business units / applications Dependency Management Aware Cloud Function Ready 12 Factor Compliant Developmer Governance Friendly Extensible Highly Flexible Academically; Enterprise Startup compatible","title":"Understanding"},{"location":"governance/installing/","text":"Installing Cyvive.io Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Requirements Compatible backend container orchestrator such as Kubernetes Cluster Administrator access Firewall access to containers stored on 'Google Container Registry' (This should already be enabled in most cluster orchestration setups) What Occurs In Cluster \u2026 will have slight variations in execution based on the selected orchestration backend, but the end interaction process is the same. Cyvive.io is installed in the system namespace an internal endpoint is created for access a 'httpie' container is created for simplified manual interaction with Cyvive.io a configMap is created to store Cyvive.io 's database information. Kubernetes Installation \u2026 is conducted via kubectl, and has been simplified down to a single command. {KubernetesVersion} should be replaced with 'v1.8' or the Major Minor Version of your cluster kubectl apply -f https://raw.githubusercontent.com/TayloredTechnology/www.cyvive.io/master/docs/deploy/kubernetes/v1.8/cyvive.yaml Note Cyvive.io is perfectly suitable to run within a 'MiniKube' environment Interacting with HTTPIE Pod export HTTP_POD=$(kubectl get pods -n kube-system -l cyvive=httpie -o name | cut -d / -f2) kubectl exec -ti -n kube-system ${HTTP_POD} bash HTTPIE Instructions can be helpful for first timers, naturally any REST compatible tool would be suitable. For example to create a deploymentTarget for all applications / services governed by Cyvive.io http POST cyvive:3000/namespace deploymentTarget=development template=dev Next Steps \u2026 vary in complexity depending on the role inhabited within the organisation Governance - Cluster - Organizational Developer","title":"Installing _Cyvive.io_"},{"location":"governance/installing/#installing-cyviveio","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate.","title":"Installing Cyvive.io"},{"location":"governance/installing/#requirements","text":"Compatible backend container orchestrator such as Kubernetes Cluster Administrator access Firewall access to containers stored on 'Google Container Registry' (This should already be enabled in most cluster orchestration setups)","title":"Requirements"},{"location":"governance/installing/#what-occurs-in-cluster","text":"\u2026 will have slight variations in execution based on the selected orchestration backend, but the end interaction process is the same. Cyvive.io is installed in the system namespace an internal endpoint is created for access a 'httpie' container is created for simplified manual interaction with Cyvive.io a configMap is created to store Cyvive.io 's database information.","title":"What Occurs In Cluster"},{"location":"governance/installing/#kubernetes-installation","text":"\u2026 is conducted via kubectl, and has been simplified down to a single command. {KubernetesVersion} should be replaced with 'v1.8' or the Major Minor Version of your cluster kubectl apply -f https://raw.githubusercontent.com/TayloredTechnology/www.cyvive.io/master/docs/deploy/kubernetes/v1.8/cyvive.yaml Note Cyvive.io is perfectly suitable to run within a 'MiniKube' environment","title":"Kubernetes Installation"},{"location":"governance/installing/#interacting-with-httpie-pod","text":"export HTTP_POD=$(kubectl get pods -n kube-system -l cyvive=httpie -o name | cut -d / -f2) kubectl exec -ti -n kube-system ${HTTP_POD} bash HTTPIE Instructions can be helpful for first timers, naturally any REST compatible tool would be suitable. For example to create a deploymentTarget for all applications / services governed by Cyvive.io http POST cyvive:3000/namespace deploymentTarget=development template=dev","title":"Interacting with HTTPIE Pod"},{"location":"governance/installing/#next-steps","text":"\u2026 vary in complexity depending on the role inhabited within the organisation Governance - Cluster - Organizational Developer","title":"Next Steps"},{"location":"governance/configuration/","text":"Application / Service YAML Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Info Scope: App / Service Specific File: cyvive.yaml Location: Application / Service Repository / CI/CD Pushed Understanding \u2026 core meta component for governance. This file describes the specific application / service's governance policy to be extracted and implemented on demand in the cluster orchestration infrastructure. While Cyvive.io doesn't mandate a specific adoption approach, a truely minimal configuration file is achieved through following industry best practices for structure and oragnisation. Cyvive.io 's configuration language is architecturally and contexturally derived from over 35 specifilized industry and academic works for providing a governance via policy meta-model that agnostically interfaces with the most complex orchestration technology while articulately able to be used in conversation. This file is a powerhouse behind agnostic infrastructure, and provides the most simple abstraction of deployment available today. Absolute Minimum File Structure Note '\u21db' character is used throughout this documentation where items are mandatory with respect to the parent YAML key. If not specified, then item is optional. exampleGroup: \u21db exampleApp: \u21db version: v1.8.x \u2026 this minimum structure is all that is necessary for Cyvive.io to commence governance and interface with the orchestration technology at a minimum level. If Cyvive.io was then used to govern this application / service in a deploymentTarget called 'preproduction' using the template 'perf' against Kubernetes as a orchestrator the following would happen: a Deployment would be created using the image: exampleGroup/exampleApp:v1.8.x a Service would be created mapping port 80 to the Deployment a DNS entry would be created in the cluster as exampleApp.exampleGroup.preproduction.svc.cluster.local any other applications governed by Cyvive.io 's and allowed to be deployed against this template would also be deployed following an automated dependency order. Note SemVer is rapidly becoming the version management approach of choice for development as it balances the needs of devoplers and continous container deployment well while maintaining business requirements for release management and change requests. Application / Service Inheritence Structure exampleGroup: \u21db exampleApp: component: identifier \u21db version: vTag \u2026 the typical structure used in a governance model would provide components , applications , groups as units of categorization. Cyvive.io inherits this concept where typically groups would be a higher level Business Unit or Service containing MicroServices and depending on the complexity of the higher level group service components (also often refered to as CloudFunctions or NanoServices ) The exact definition and demarkation of groups is left to the client, but by default when requesting a container from the container repository the format will be as such: exampleGroup/exampleApp-component:vTag naturally lending to the following organisation use-cases: Business Unit Separation every logical business unit has a collection of apps that interface with other parts of the business / consumer. Service Oriented Architecture where a collection of microservices are combined to form a logical unit. i.e. Frontend (Browser), Backend (API), DataBase As such its possible to use Cyvive.io with any level of complexity in application releationships, while keeping isolation and deployment in a layered security approach. Group Level Configuration / Technology Descriptor exampleGroup exampleApp: {} group: {} \u2026 is available for all groups under governance. Where applicable identical specifications at the group level override the template level. Its not necessary for group information to be specified as a pre-requisite to adding a Service / Application / Component to a non-existent group. It is possible Service / Application / Component to inherit configuration information from the group level, thus allowing enhanced security over a traditional deployment model, where keys can be present in the application environment and unknown to developers with Service / Application / Component source code access. Additional information on the group Technology Descriptors is available Application / Service Technology Descriptor exampleGroup exampleApp: availability: {} circuitBreaker: {} commandLineInterface: {} component: string daemon: boolean endpoint: {} environment: {} label: {} layer: string repository: {} resource: {} security: {} stateful: {} version: {} \u2026 illustrates a high level overview of the logical configuration sections. Detailed information is located under each subheading below. Where values for keys are shown they are the default values. availability exampleGroup: exampleApp: availability: gracePeriod: boot: 1 stability: 0 termination: 5 minimum: 1 maximum: 2 probe: health: interval: 10 path: / port: 80 ready: interval: 5 path: / port: 80 timeout: 1 scalingEvent: {} gracePeriod : minimum time in seconds to wait for events to occur boot : Service / Application / Component operating system startup boot time, this should be the minimum time before a health check endpoint is available to process a request. stability : amount of time to wait for the health check endpoint to ensure consistent returns after boot time has been completed. This is typically used in legacy applications that need to stabilize their upstream and downstream communications when started or have large amounts of data to sync. termination : is the maximum amount of time to wait before hard terminating the container operating system. It does not guarantee the Service / Application / Component will have or take this long to terminate, its just the maximum amount of time to wait for the signal from the Operating System to ensure its okay to terminate. (Note: the termination signal is sent immediately to all container processes, this is the period before the kill signal is sent) minimum : guaranteed minimum number of replicas to always be deployed in the deploymentTarget maximum : when scaling ensure that this number is not exceeded probes : notify the underlying orchestrator of Service / Application / Component status. Where health is actual health, and ready is ability to recieve traffic interval : time in seconds for checking endpoint path : endpoint path relative to container port : internal port the probe endpoint is listening on timeout : this option is not nested under each probe as failures are being monitored for, its expected that timeout values should apply to all check related endpoints equally. scalingEvent : is a passthrough object of trigger events to integrate with orchestration support in triggering scaling up and down of the replicas. Note: With respect to deployment timeouts, Cyvive.io 's standard approach is to stall deployments as failed if the Service / Application / Component takes fails to enter ready state using one of the following timelines in order of priority rounded to the nearest second: probe.ready specified: (gracePeriod.boot + gracePeriod.stability + (probe.ready.interval * 2)) * 3.3 probe.health specified: (gracePeriod.boot + gracePeriod.stability + probe.health.interval) * 3.3 gracePeriod.stability : (gracePeriod.boot + gracePeriod.stability + 10) * 3.3 gracePeriod.boot : (gracePeriod.boot + 10) * 3.3 default settings : 33 seconds As seen above 10% buffer is applied to times to ensure container schedulling / restarting via the orchestrator doesn't introduce false-positives circuitBreaker available to closed beta customers commandLineInterface exampleGroup: exampleApp: commandLineInterface: argument: [] command: \u2026 is an override path for container start commands. While most startups will embed the start command and respective arguments in the container image itself, efficient governance exposes all configuration, execution and dependency information. As such the organisation can choose to embed startup information in the container or expose via governance layer. argument : standard cli arguments for execution. e.g. ['--list', '--debug'] command : root command to execute when starting the container. e.g. '/usr/local/bin/command' should this not be specified then the default command the container was built with will be executed. component exampleGroup: exampleApp: component: \u2026 provides a namespace separation for components . Typically used when the Service / Application would need to be logicaly broken down further than just Business Unit / Group to Service / Application daemon exampleGroup: exampleApp: daemon: false \u2026 upgrades the Service / Application / Component to run as a Daemon in the deploymentTarget . This ensures that every physical node executing a Service / Application / Component belonging to this group will have this Daemon available locally. endpoint exampleGroup: exampleApp: endpoint: domain: {} port: 80 provide: [ / ] scheme: https require: {} \u2026 are created for every Service / Application / Component by default and register DNS via the following schema: component-appName.groupName.deploymentTarget.domain port : open port for inbound interaction. provide : important for correct dependency management the provide endpoints are the registration points for Service / Application / Component searching in generating the deployment graph. scheme : extensible against the scheme definitions in RFC standards, the key types are http and https where specifying https will cause auto-creation of SSL certificates at the cluster ingress point. Exploring the complex root keys: domain: xyz.com : [ DEVLIKE , HALIKE , PRODLIKE ] testing.co : [ DEVLIKE ] The domain object is structured as follows: - key : the domain name to expose against. This should be the Fully Qualified Domain Name ( FQDN ) as autogenerated DNS structure applies inside the cluster only. - value : array of operatingEnvironment 's valid for exposing against. Exposure follows the schema mentioned previously, however it can be overridden as necessary require: - redux.exampleGroup:443/api/v1/ending : [ incoming ] - exampleApp.exampleGroup:80/v1/ : [ incoming , outgoing ] - 162.0.5.2:8080/ : [ outgoing ] The require object is quite important. It identifies all dependencies this Service / Application / Component has and helps contribute to the deployment order when creating a deploymentTarget . In the event a require is not registered with Cyvive.io it will be considered external to the cluster and assumed to already exist. A useful note is that different versions of the same Service / Application / Component can be consumed by other eachother. This is achieved via the version key where each governance technology descriptor registers against the Service / Application / Component version. The require object is structured as follows: - key : Uniform Resource Identifier (URI) RFC 3986 compliant. The scheme is unnecessary as any routing restrictions - value : traffic direction for filewall / security registration environment exampleGroup: exampleApp: environment: file: config: {} secret: {} variable: {} \u2026 all items are directly exposed to the Service / Application / Component. Exploring the complex root keys: files: config: alpha : mountPath: /alpha data: - name: configDetail value: string of information delta : inheritGroup: false Each item in config is a representation of a ConfigMap with individual items specified in the array object under data . Each item represents an individual file. mountPath is the directory location in the container that the ConfigMap should be mounted to. If inheritGroup is provided the configuration will be loaded from the group settings enabling a more 'global' oriented view of configuration files: secrets: secretname : type: opaque mountPath: /secret-location data: - name: secretInfo value: (base64 string) anothersecret : inheritGroup: false Each item in secrets is a map with individual items under data representing files to be mounted into the mountPath location in the container. If inheritGroup is provided the secret will be loaded from the group settings enabling a more 'global' oriented view of configuration variable: exposeName : exposeValue Direct mapping of the key to value provided as an environmental variable when executing the container start command. Additionally Cyvive.io exposes some helper variables to identify the current context of the Service / Application / Component: SELF_NAME : name of the Service / Application / Component. This will also be the hostname of the running container SELF_NAME_LOADBALANCER : to assist in discovery, this is the LoadBalancer endpoint for incluster communication to this container and its replicas. This is relative to the deploymentTarget and not the Fully Qualified Domain Name (FQDN) SELF_DEPLOYMENTTARGET : deploymentTarget that the Service / Application / Component has been deployed into SELF_IP : the internal cluster IP of the container The following self-explanatory variables are also available to the container when specified via Cyvive.io 's governance: SELF_MIN_MEMORY SELF_MIN_CPU SELF_MAX_MEMORY SELF_MAX_CPU hardWired exampleGroup: exampleApp: hardWired: clusterDNS: \u2026 is a catch-all for compatibility with non-governed processes. It is strongly recommended not to use these keys unless absolutely necessary as each key will disable some governance functionality and introduce independent manual management scenarios that wouldn't normally be necessary. clusterDNS : is a hard overwrite of the cluster internal load balancer endpoint for the Service / Application / Component. It disables the autogeneration capabilities and can help with initially migrating non Cloud Native items. label exampleGroup: exampleApp: label: # app: autocompleted ~ appName # component: autocompleted ~ component # release: autocompleted in PRODLIKE environments ~ canary or stable # tier: autocompleted ~ groupName # version: autocompleted ~ version key {any others you require} Any labels not specified above can be used to help identify the applications services. As the aforeentioned labels are reserved by Cyvive.io for governance, any custom values provided will be ignored as they are used for asset tracking Although there is nothing stopping its use, the recommended approach is not to use hotfix as a label or blue / green for deploys as when running Services / Application / Components en masse at scale, canary has been observed repeatedly as a more stable; reduced risk; and governable approach as everything passes through a 'canary' state anyway. (Under candidate based releases hotfixes are just releases that have been accelerated through the canary phase) There is no limit to how many labels can be specified layer exampleGroup: exampleApp: layer: base \u2026 is a concept often used in Enterprise Architecture and earlier microservices. Cyvive.io underwent an extreemly careful active engagement process with its users prior to introducing this key. The layer concept is used as part of the dependency graph generation process. Prioritizing and guaranteeing deployments of each layer prior to commencing the next, failing fast when any layer fails to deploy. Layers in Order 1. data 2. communication 3. cache 4. backend 5. frontend While strictly not necessary to specify, if known the layer should be specified as it allows for accelerated parallel deployment in the desired deploymentTarget repository exampleGroup exampleApp: repository: image: domain: hub.docker.io name: exampleRedux officialImage: false owner: exampleRedux \u2026 image registry autogenerated name uses the format: repository/owner/name as such the default without image specified would be hub.docker.io/exampleGroup/exampleApp . This can be overriden to anything you need in any combination using the following values: domain : overrides group or template domain settings name : overrides exampleApp in the sample. This impacts deployed application name container image repository url generation. officialImage : is a structureal specification for DockerHub where official images have a different retrieval structure. Setting this as true would result in exampleApp being the official image name or if provided name would still override to be the official image name. owner : override for owner in technology descriptor resource exampleGroup: exampleApp: resource: max: cpu: 500 memory: 1Gi min: cpu: 300 memory: 1Gi qos: \u2026 allocation is an important part of all container orchestration schedullers, and these values should be provided prior to deploying Service / Application / Component to production deploymentTarget although, if not specified Cyvive.io will operate without issue. max absolute maximum requirements that we are prepared to allocate. min minimum required in order to guarantee application boot and ready for traffic interaction. qos is mandatory should min or max be specified If neither min or max are specified then template defaults (if specified) will be used. The ability to provide template resource defaults is to ensure safe co-habitation of Services / Applications / Components when / if they go rogue. cpu is units of CPU core specified in 'm' thus for a single CPU core 1000 should be used. The 'm' is omitted and should not be specified. memory should always have the multiplier specified as part of the value i.e. 'Gi' any suitable value can be specified from the following: Ki Mi Gi Ti Pi Ei qos follows the approach: guaranteed : highest possible level, everything not this level will suffer 'pause' events to ensure these pods continue to operate. burstable : default min values are allocated to the pod as minimum required to run. No upper limits are placed on resources. effort : can be used when the application is lowest priority of them all. min , max and namespace default values are totally ignored. (Currently un-implemented due to lack of user demand) security available to closed beta customers exampleGroup: exampleApp: security: account: name: alternativeOne reference: admin account : should an account be required that isn't the group security account or 'default' i.e. another group's account. It can be overriden here. Specifying will create the account if it doesn't exist stateful exampleGroup: exampleApp stateful: cloudNative: false databaseName: individualServices: false replica: 3 sharedStorage: false volume: avolume : mountPath: /avolume size: 10Gi storageClass: cloudNative : Enables the ability to deploy stateful applications in parallel and will automatically compact number of replicas down in envionments that aren't 'HALIKE' or 'PRODLIKE' to save resources. databaseName : standard application naming will be applied if this field is omitted. Its frequently used in custom templates for configuring some of the expected internals individualServices : some applications can operate under a common service endpoint, others such as MongoDB require fixed service endpoints for each database replica : number of PODS that should be deployed, if the backend supports it anti-affinity rules will already be in place per Availablility Zone and Host. sharedStorage : determines if the PODS should have mount the same storage or have unique storage per pod ( warhing multi-mount storage is unsupported by most storage drivers) storageClass : the type of storage strategy that should be applied In providing a consistent minimal configuration the stateful configuration integrates with endpoint and it should be used for accessing accordingly Amount of time that should be given after sending kill signal to the container OS before terminating and removing the container. version exampleGroup: exampleApp: version: latest \u2026 standards and application is a constantly debated aproach with different internal standards used within organizations. Internally Cyvive.io maintains governance versions based on this key and value . For effective governance of infrastructure in cloud native approaches Semantic Versioning SemVer is sanest choice. Cyvive.io 's integration with SemVer only tracks major minor patch the extensions format is stripped off for tracking purposes. If its necessary to modify governance information, then the SevVer should be incremented to prevent cross-contamination of prior governed assets. Container images when using SemVer are not re-pulled from the image repository each time as they should be immuntable. static labels i.e. latest can also be used with the understanding that configuration changes will be applied to all future deploymentTarget and container images will be re-pulled every time.","title":"Component"},{"location":"governance/configuration/#application-service-yaml","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Info Scope: App / Service Specific File: cyvive.yaml Location: Application / Service Repository / CI/CD Pushed","title":"Application / Service YAML"},{"location":"governance/configuration/#understanding","text":"\u2026 core meta component for governance. This file describes the specific application / service's governance policy to be extracted and implemented on demand in the cluster orchestration infrastructure. While Cyvive.io doesn't mandate a specific adoption approach, a truely minimal configuration file is achieved through following industry best practices for structure and oragnisation. Cyvive.io 's configuration language is architecturally and contexturally derived from over 35 specifilized industry and academic works for providing a governance via policy meta-model that agnostically interfaces with the most complex orchestration technology while articulately able to be used in conversation. This file is a powerhouse behind agnostic infrastructure, and provides the most simple abstraction of deployment available today.","title":"Understanding"},{"location":"governance/configuration/#absolute-minimum-file-structure","text":"Note '\u21db' character is used throughout this documentation where items are mandatory with respect to the parent YAML key. If not specified, then item is optional. exampleGroup: \u21db exampleApp: \u21db version: v1.8.x \u2026 this minimum structure is all that is necessary for Cyvive.io to commence governance and interface with the orchestration technology at a minimum level. If Cyvive.io was then used to govern this application / service in a deploymentTarget called 'preproduction' using the template 'perf' against Kubernetes as a orchestrator the following would happen: a Deployment would be created using the image: exampleGroup/exampleApp:v1.8.x a Service would be created mapping port 80 to the Deployment a DNS entry would be created in the cluster as exampleApp.exampleGroup.preproduction.svc.cluster.local any other applications governed by Cyvive.io 's and allowed to be deployed against this template would also be deployed following an automated dependency order. Note SemVer is rapidly becoming the version management approach of choice for development as it balances the needs of devoplers and continous container deployment well while maintaining business requirements for release management and change requests.","title":"Absolute Minimum File Structure"},{"location":"governance/configuration/#application-service-inheritence-structure","text":"exampleGroup: \u21db exampleApp: component: identifier \u21db version: vTag \u2026 the typical structure used in a governance model would provide components , applications , groups as units of categorization. Cyvive.io inherits this concept where typically groups would be a higher level Business Unit or Service containing MicroServices and depending on the complexity of the higher level group service components (also often refered to as CloudFunctions or NanoServices ) The exact definition and demarkation of groups is left to the client, but by default when requesting a container from the container repository the format will be as such: exampleGroup/exampleApp-component:vTag naturally lending to the following organisation use-cases: Business Unit Separation every logical business unit has a collection of apps that interface with other parts of the business / consumer. Service Oriented Architecture where a collection of microservices are combined to form a logical unit. i.e. Frontend (Browser), Backend (API), DataBase As such its possible to use Cyvive.io with any level of complexity in application releationships, while keeping isolation and deployment in a layered security approach.","title":"Application / Service Inheritence Structure"},{"location":"governance/configuration/#group-level-configuration-technology-descriptor","text":"exampleGroup exampleApp: {} group: {} \u2026 is available for all groups under governance. Where applicable identical specifications at the group level override the template level. Its not necessary for group information to be specified as a pre-requisite to adding a Service / Application / Component to a non-existent group. It is possible Service / Application / Component to inherit configuration information from the group level, thus allowing enhanced security over a traditional deployment model, where keys can be present in the application environment and unknown to developers with Service / Application / Component source code access. Additional information on the group Technology Descriptors is available","title":"Group Level Configuration / Technology Descriptor"},{"location":"governance/configuration/#application-service-technology-descriptor","text":"exampleGroup exampleApp: availability: {} circuitBreaker: {} commandLineInterface: {} component: string daemon: boolean endpoint: {} environment: {} label: {} layer: string repository: {} resource: {} security: {} stateful: {} version: {} \u2026 illustrates a high level overview of the logical configuration sections. Detailed information is located under each subheading below. Where values for keys are shown they are the default values.","title":"Application / Service Technology Descriptor"},{"location":"governance/configuration/#availability","text":"exampleGroup: exampleApp: availability: gracePeriod: boot: 1 stability: 0 termination: 5 minimum: 1 maximum: 2 probe: health: interval: 10 path: / port: 80 ready: interval: 5 path: / port: 80 timeout: 1 scalingEvent: {} gracePeriod : minimum time in seconds to wait for events to occur boot : Service / Application / Component operating system startup boot time, this should be the minimum time before a health check endpoint is available to process a request. stability : amount of time to wait for the health check endpoint to ensure consistent returns after boot time has been completed. This is typically used in legacy applications that need to stabilize their upstream and downstream communications when started or have large amounts of data to sync. termination : is the maximum amount of time to wait before hard terminating the container operating system. It does not guarantee the Service / Application / Component will have or take this long to terminate, its just the maximum amount of time to wait for the signal from the Operating System to ensure its okay to terminate. (Note: the termination signal is sent immediately to all container processes, this is the period before the kill signal is sent) minimum : guaranteed minimum number of replicas to always be deployed in the deploymentTarget maximum : when scaling ensure that this number is not exceeded probes : notify the underlying orchestrator of Service / Application / Component status. Where health is actual health, and ready is ability to recieve traffic interval : time in seconds for checking endpoint path : endpoint path relative to container port : internal port the probe endpoint is listening on timeout : this option is not nested under each probe as failures are being monitored for, its expected that timeout values should apply to all check related endpoints equally. scalingEvent : is a passthrough object of trigger events to integrate with orchestration support in triggering scaling up and down of the replicas. Note: With respect to deployment timeouts, Cyvive.io 's standard approach is to stall deployments as failed if the Service / Application / Component takes fails to enter ready state using one of the following timelines in order of priority rounded to the nearest second: probe.ready specified: (gracePeriod.boot + gracePeriod.stability + (probe.ready.interval * 2)) * 3.3 probe.health specified: (gracePeriod.boot + gracePeriod.stability + probe.health.interval) * 3.3 gracePeriod.stability : (gracePeriod.boot + gracePeriod.stability + 10) * 3.3 gracePeriod.boot : (gracePeriod.boot + 10) * 3.3 default settings : 33 seconds As seen above 10% buffer is applied to times to ensure container schedulling / restarting via the orchestrator doesn't introduce false-positives","title":"availability"},{"location":"governance/configuration/#circuitbreaker","text":"available to closed beta customers","title":"circuitBreaker"},{"location":"governance/configuration/#commandlineinterface","text":"exampleGroup: exampleApp: commandLineInterface: argument: [] command: \u2026 is an override path for container start commands. While most startups will embed the start command and respective arguments in the container image itself, efficient governance exposes all configuration, execution and dependency information. As such the organisation can choose to embed startup information in the container or expose via governance layer. argument : standard cli arguments for execution. e.g. ['--list', '--debug'] command : root command to execute when starting the container. e.g. '/usr/local/bin/command' should this not be specified then the default command the container was built with will be executed.","title":"commandLineInterface"},{"location":"governance/configuration/#component","text":"exampleGroup: exampleApp: component: \u2026 provides a namespace separation for components . Typically used when the Service / Application would need to be logicaly broken down further than just Business Unit / Group to Service / Application","title":"component"},{"location":"governance/configuration/#daemon","text":"exampleGroup: exampleApp: daemon: false \u2026 upgrades the Service / Application / Component to run as a Daemon in the deploymentTarget . This ensures that every physical node executing a Service / Application / Component belonging to this group will have this Daemon available locally.","title":"daemon"},{"location":"governance/configuration/#endpoint","text":"exampleGroup: exampleApp: endpoint: domain: {} port: 80 provide: [ / ] scheme: https require: {} \u2026 are created for every Service / Application / Component by default and register DNS via the following schema: component-appName.groupName.deploymentTarget.domain port : open port for inbound interaction. provide : important for correct dependency management the provide endpoints are the registration points for Service / Application / Component searching in generating the deployment graph. scheme : extensible against the scheme definitions in RFC standards, the key types are http and https where specifying https will cause auto-creation of SSL certificates at the cluster ingress point. Exploring the complex root keys: domain: xyz.com : [ DEVLIKE , HALIKE , PRODLIKE ] testing.co : [ DEVLIKE ] The domain object is structured as follows: - key : the domain name to expose against. This should be the Fully Qualified Domain Name ( FQDN ) as autogenerated DNS structure applies inside the cluster only. - value : array of operatingEnvironment 's valid for exposing against. Exposure follows the schema mentioned previously, however it can be overridden as necessary require: - redux.exampleGroup:443/api/v1/ending : [ incoming ] - exampleApp.exampleGroup:80/v1/ : [ incoming , outgoing ] - 162.0.5.2:8080/ : [ outgoing ] The require object is quite important. It identifies all dependencies this Service / Application / Component has and helps contribute to the deployment order when creating a deploymentTarget . In the event a require is not registered with Cyvive.io it will be considered external to the cluster and assumed to already exist. A useful note is that different versions of the same Service / Application / Component can be consumed by other eachother. This is achieved via the version key where each governance technology descriptor registers against the Service / Application / Component version. The require object is structured as follows: - key : Uniform Resource Identifier (URI) RFC 3986 compliant. The scheme is unnecessary as any routing restrictions - value : traffic direction for filewall / security registration","title":"endpoint"},{"location":"governance/configuration/#environment","text":"exampleGroup: exampleApp: environment: file: config: {} secret: {} variable: {} \u2026 all items are directly exposed to the Service / Application / Component. Exploring the complex root keys: files: config: alpha : mountPath: /alpha data: - name: configDetail value: string of information delta : inheritGroup: false Each item in config is a representation of a ConfigMap with individual items specified in the array object under data . Each item represents an individual file. mountPath is the directory location in the container that the ConfigMap should be mounted to. If inheritGroup is provided the configuration will be loaded from the group settings enabling a more 'global' oriented view of configuration files: secrets: secretname : type: opaque mountPath: /secret-location data: - name: secretInfo value: (base64 string) anothersecret : inheritGroup: false Each item in secrets is a map with individual items under data representing files to be mounted into the mountPath location in the container. If inheritGroup is provided the secret will be loaded from the group settings enabling a more 'global' oriented view of configuration variable: exposeName : exposeValue Direct mapping of the key to value provided as an environmental variable when executing the container start command. Additionally Cyvive.io exposes some helper variables to identify the current context of the Service / Application / Component: SELF_NAME : name of the Service / Application / Component. This will also be the hostname of the running container SELF_NAME_LOADBALANCER : to assist in discovery, this is the LoadBalancer endpoint for incluster communication to this container and its replicas. This is relative to the deploymentTarget and not the Fully Qualified Domain Name (FQDN) SELF_DEPLOYMENTTARGET : deploymentTarget that the Service / Application / Component has been deployed into SELF_IP : the internal cluster IP of the container The following self-explanatory variables are also available to the container when specified via Cyvive.io 's governance: SELF_MIN_MEMORY SELF_MIN_CPU SELF_MAX_MEMORY SELF_MAX_CPU","title":"environment"},{"location":"governance/configuration/#hardwired","text":"exampleGroup: exampleApp: hardWired: clusterDNS: \u2026 is a catch-all for compatibility with non-governed processes. It is strongly recommended not to use these keys unless absolutely necessary as each key will disable some governance functionality and introduce independent manual management scenarios that wouldn't normally be necessary. clusterDNS : is a hard overwrite of the cluster internal load balancer endpoint for the Service / Application / Component. It disables the autogeneration capabilities and can help with initially migrating non Cloud Native items.","title":"hardWired"},{"location":"governance/configuration/#label","text":"exampleGroup: exampleApp: label: # app: autocompleted ~ appName # component: autocompleted ~ component # release: autocompleted in PRODLIKE environments ~ canary or stable # tier: autocompleted ~ groupName # version: autocompleted ~ version key {any others you require} Any labels not specified above can be used to help identify the applications services. As the aforeentioned labels are reserved by Cyvive.io for governance, any custom values provided will be ignored as they are used for asset tracking Although there is nothing stopping its use, the recommended approach is not to use hotfix as a label or blue / green for deploys as when running Services / Application / Components en masse at scale, canary has been observed repeatedly as a more stable; reduced risk; and governable approach as everything passes through a 'canary' state anyway. (Under candidate based releases hotfixes are just releases that have been accelerated through the canary phase) There is no limit to how many labels can be specified","title":"label"},{"location":"governance/configuration/#layer","text":"exampleGroup: exampleApp: layer: base \u2026 is a concept often used in Enterprise Architecture and earlier microservices. Cyvive.io underwent an extreemly careful active engagement process with its users prior to introducing this key. The layer concept is used as part of the dependency graph generation process. Prioritizing and guaranteeing deployments of each layer prior to commencing the next, failing fast when any layer fails to deploy. Layers in Order 1. data 2. communication 3. cache 4. backend 5. frontend While strictly not necessary to specify, if known the layer should be specified as it allows for accelerated parallel deployment in the desired deploymentTarget","title":"layer"},{"location":"governance/configuration/#repository","text":"exampleGroup exampleApp: repository: image: domain: hub.docker.io name: exampleRedux officialImage: false owner: exampleRedux \u2026 image registry autogenerated name uses the format: repository/owner/name as such the default without image specified would be hub.docker.io/exampleGroup/exampleApp . This can be overriden to anything you need in any combination using the following values: domain : overrides group or template domain settings name : overrides exampleApp in the sample. This impacts deployed application name container image repository url generation. officialImage : is a structureal specification for DockerHub where official images have a different retrieval structure. Setting this as true would result in exampleApp being the official image name or if provided name would still override to be the official image name. owner : override for owner in technology descriptor","title":"repository"},{"location":"governance/configuration/#resource","text":"exampleGroup: exampleApp: resource: max: cpu: 500 memory: 1Gi min: cpu: 300 memory: 1Gi qos: \u2026 allocation is an important part of all container orchestration schedullers, and these values should be provided prior to deploying Service / Application / Component to production deploymentTarget although, if not specified Cyvive.io will operate without issue. max absolute maximum requirements that we are prepared to allocate. min minimum required in order to guarantee application boot and ready for traffic interaction. qos is mandatory should min or max be specified If neither min or max are specified then template defaults (if specified) will be used. The ability to provide template resource defaults is to ensure safe co-habitation of Services / Applications / Components when / if they go rogue. cpu is units of CPU core specified in 'm' thus for a single CPU core 1000 should be used. The 'm' is omitted and should not be specified. memory should always have the multiplier specified as part of the value i.e. 'Gi' any suitable value can be specified from the following: Ki Mi Gi Ti Pi Ei qos follows the approach: guaranteed : highest possible level, everything not this level will suffer 'pause' events to ensure these pods continue to operate. burstable : default min values are allocated to the pod as minimum required to run. No upper limits are placed on resources. effort : can be used when the application is lowest priority of them all. min , max and namespace default values are totally ignored. (Currently un-implemented due to lack of user demand)","title":"resource"},{"location":"governance/configuration/#security","text":"available to closed beta customers exampleGroup: exampleApp: security: account: name: alternativeOne reference: admin account : should an account be required that isn't the group security account or 'default' i.e. another group's account. It can be overriden here. Specifying will create the account if it doesn't exist","title":"security"},{"location":"governance/configuration/#stateful","text":"exampleGroup: exampleApp stateful: cloudNative: false databaseName: individualServices: false replica: 3 sharedStorage: false volume: avolume : mountPath: /avolume size: 10Gi storageClass: cloudNative : Enables the ability to deploy stateful applications in parallel and will automatically compact number of replicas down in envionments that aren't 'HALIKE' or 'PRODLIKE' to save resources. databaseName : standard application naming will be applied if this field is omitted. Its frequently used in custom templates for configuring some of the expected internals individualServices : some applications can operate under a common service endpoint, others such as MongoDB require fixed service endpoints for each database replica : number of PODS that should be deployed, if the backend supports it anti-affinity rules will already be in place per Availablility Zone and Host. sharedStorage : determines if the PODS should have mount the same storage or have unique storage per pod ( warhing multi-mount storage is unsupported by most storage drivers) storageClass : the type of storage strategy that should be applied In providing a consistent minimal configuration the stateful configuration integrates with endpoint and it should be used for accessing accordingly Amount of time that should be given after sending kill signal to the container OS before terminating and removing the container.","title":"stateful"},{"location":"governance/configuration/#version","text":"exampleGroup: exampleApp: version: latest \u2026 standards and application is a constantly debated aproach with different internal standards used within organizations. Internally Cyvive.io maintains governance versions based on this key and value . For effective governance of infrastructure in cloud native approaches Semantic Versioning SemVer is sanest choice. Cyvive.io 's integration with SemVer only tracks major minor patch the extensions format is stripped off for tracking purposes. If its necessary to modify governance information, then the SevVer should be incremented to prevent cross-contamination of prior governed assets. Container images when using SemVer are not re-pulled from the image repository each time as they should be immuntable. static labels i.e. latest can also be used with the understanding that configuration changes will be applied to all future deploymentTarget and container images will be re-pulled every time.","title":"version"},{"location":"governance/configuration/groups/","text":"Group YAML Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Info Scope: Group for Application / Service / Component Inheritence File: *.group.yaml Location: Governance Repository / CI/CD Pushed Understanding \u2026 core meta component for governance. This file describes the specific group level governance policy to be extracted and implemented on demand in the cluster orchestration infrastructure against Service / Application / Component registered against this group. Cyvive.io 's configuration language is architecturally and contexturally derived from over 35 specifilized industry and academic works for providing a governance via policy meta-model that agnostically interfaces with the most complex orchestration technology while articulately able to be used in conversation. This file is a powerhouse behind agnostic infrastructure, and provides the most simple abstraction of deployment available today. Group Level Configuration / Technology Descriptor exampleGroup: group: environment: {} repository: image: auth: {} domain: hub.docker.io owner: exampleRedux security: {} \u2026 group is a reserved keyword. It directly specifies that all keys present are applied to all applications / services also registered against the group. environment \u2026 structural copy of Service / Application / Component Environment repository exampleGroup: group: repository: image: auth: {} domain: hub.docker.io owner: exampleRedux \u2026 defaults for Service / Application / Components related to this group . Typically the group would map directly to a business unit or complex service. Based on this, the group 's may be logically stored in different image repositories. There are some differences from Service / Application / Componenent Repository as can be seen below image: auth: exampleGroup : ZmF0aG9tYWJsZQo= domain: gcr.io owner: internal auth : is a series of base64 encoded objects containing the Docker login information. domain : container repository domain information, this will become the default for all items registered against this group owner : change the default owner from the group name (e.g. exampleGroup) for all items registered against this group security \u2026 structural copy of Service / Application / Component Security","title":"Groups"},{"location":"governance/configuration/groups/#group-yaml","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Info Scope: Group for Application / Service / Component Inheritence File: *.group.yaml Location: Governance Repository / CI/CD Pushed","title":"Group YAML"},{"location":"governance/configuration/groups/#understanding","text":"\u2026 core meta component for governance. This file describes the specific group level governance policy to be extracted and implemented on demand in the cluster orchestration infrastructure against Service / Application / Component registered against this group. Cyvive.io 's configuration language is architecturally and contexturally derived from over 35 specifilized industry and academic works for providing a governance via policy meta-model that agnostically interfaces with the most complex orchestration technology while articulately able to be used in conversation. This file is a powerhouse behind agnostic infrastructure, and provides the most simple abstraction of deployment available today.","title":"Understanding"},{"location":"governance/configuration/groups/#group-level-configuration-technology-descriptor","text":"exampleGroup: group: environment: {} repository: image: auth: {} domain: hub.docker.io owner: exampleRedux security: {} \u2026 group is a reserved keyword. It directly specifies that all keys present are applied to all applications / services also registered against the group.","title":"Group Level Configuration / Technology Descriptor"},{"location":"governance/configuration/groups/#environment","text":"\u2026 structural copy of Service / Application / Component Environment","title":"environment"},{"location":"governance/configuration/groups/#repository","text":"exampleGroup: group: repository: image: auth: {} domain: hub.docker.io owner: exampleRedux \u2026 defaults for Service / Application / Components related to this group . Typically the group would map directly to a business unit or complex service. Based on this, the group 's may be logically stored in different image repositories. There are some differences from Service / Application / Componenent Repository as can be seen below image: auth: exampleGroup : ZmF0aG9tYWJsZQo= domain: gcr.io owner: internal auth : is a series of base64 encoded objects containing the Docker login information. domain : container repository domain information, this will become the default for all items registered against this group owner : change the default owner from the group name (e.g. exampleGroup) for all items registered against this group","title":"repository"},{"location":"governance/configuration/groups/#security","text":"\u2026 structural copy of Service / Application / Component Security","title":"security"},{"location":"governance/configuration/templates/","text":"Templates YAML Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Info Scope: deploymentTarget File: *.template.yaml Understanding \u2026 core meta component for governance. This file describes the template 's available for deploymentTarget to be created from. Its the highest level of inheritance for governance and configuration when deploying a collection of Service / Application / Components into a deploymentTarget . Specified items are inherited as low priority defaults unless overriden. Cyvive.io 's configuration language is architecturally and contexturally derived from over 35 specifilized industry and academic works for providing a governance via policy meta-model that agnostically interfaces with the most complex orchestration technology while articulately able to be used in conversation. This file is a powerhouse behind agnostic infrastructure, and provides the most simple abstraction of deployment available today. Template Technology Descriptors \u2026 are logically grouped into four meta-categories, and while the individual template can have any name assigned to it, the template must belong to a meta-category. Where each meta-catagory is based on the following operatingEnvironment logical progression: development \u21db high availability development \u21db performance \u21db production Default Template Names dev (type: development ) - single container availability - minimum resource allocation - probes: - ready ha (type: high availability development ) - dual container availability - minimum resource allocation - probes: - ready perf (type: performance ) - dual container availability - maximum resource allocation - probes: - ready - health prod (type: production ) - high availability - horizonal autoscaling - maximum resource allocation - probes: - ready - health template type selection is controlled via the operatingEnvironment field. The following states select the operatingEnvironment : - [] @ dev (default) - ['DEVLIKE'] @ dev (alterantive for direct specification) - ['HALIKE'] @ ha - ['PRODLIKE'] @ prod - ['HALIKE', 'PRODLIKE'] @ perf This approach enables any number of copies or versions of deploymentTarget to be deployed or updated with identical or slightly varied configuration. Additionally as the governance process is version aware, multiple versions of the Service / Application / Component can co-exist in the same deploymentTarget Cyvive.io provides this default set of Template Technology Descriptors not to enforce direction on organisations but to assist with rapid adoption and integration with existing processes. The default Templates cover all operatingEnvironment types that an organization would utilize in developing and promoting an Application / Service / Component through its Continuous Delivery / Deployment lifecycle. While isolating and adding the infrastructure complexities step by step to assist with narrowing debugging focus. When creating a deploymentTarget Cyvive.io will deploy in parallel constrained by priority order all Services / Applications / Components relying on the container orchestration technology to confirm that each Service / Application / Component has started correctly. Should a service fail to start the failure will be reported back, otherwise a sucess response will be recieved. Root Structure dev: ha: perf: prod: mandatory: (others) As mentioned previously any custom name can be used for a template except mandatory as its a reserved operatingEnvironment : All information populated in this key will be deployed into all deploymentTarget 's Should mandatory be used, it follows the same structure as Cyvive.io 's Service / Application / Component with the exception of groups as the mandatory key replaces the group key. As such the dedicated group configuration is also unavailable for mandatory Template Technology Descriptor Note '\u21db' character is used throughout this documentation where items are mandatory with respect to the parent YAML key. If not specified, then item is optional. example: environment: {} \u21db operatingEnvironment: [] resource: {} environment \u2026 structural copy of Service / Application / Component Environment operatingEnvironment dev: \u21db operatingEnvironment: \u21db [] template type selection is controlled via the operatingEnvironment field. The following states select the operatingEnvironment : - [] @ dev (default) - ['DEVLIKE'] @ dev (alterantive for direct specification) - ['HALIKE'] @ ha - ['PRODLIKE'] @ prod - ['HALIKE', 'PRODLIKE'] @ perf resource \u2026 structural copy of Service / Application / Component Resource","title":"Templates"},{"location":"governance/configuration/templates/#templates-yaml","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Info Scope: deploymentTarget File: *.template.yaml","title":"Templates YAML"},{"location":"governance/configuration/templates/#understanding","text":"\u2026 core meta component for governance. This file describes the template 's available for deploymentTarget to be created from. Its the highest level of inheritance for governance and configuration when deploying a collection of Service / Application / Components into a deploymentTarget . Specified items are inherited as low priority defaults unless overriden. Cyvive.io 's configuration language is architecturally and contexturally derived from over 35 specifilized industry and academic works for providing a governance via policy meta-model that agnostically interfaces with the most complex orchestration technology while articulately able to be used in conversation. This file is a powerhouse behind agnostic infrastructure, and provides the most simple abstraction of deployment available today.","title":"Understanding"},{"location":"governance/configuration/templates/#template-technology-descriptors","text":"\u2026 are logically grouped into four meta-categories, and while the individual template can have any name assigned to it, the template must belong to a meta-category. Where each meta-catagory is based on the following operatingEnvironment logical progression: development \u21db high availability development \u21db performance \u21db production","title":"Template Technology Descriptors"},{"location":"governance/configuration/templates/#default-template-names","text":"dev (type: development ) - single container availability - minimum resource allocation - probes: - ready ha (type: high availability development ) - dual container availability - minimum resource allocation - probes: - ready perf (type: performance ) - dual container availability - maximum resource allocation - probes: - ready - health prod (type: production ) - high availability - horizonal autoscaling - maximum resource allocation - probes: - ready - health template type selection is controlled via the operatingEnvironment field. The following states select the operatingEnvironment : - [] @ dev (default) - ['DEVLIKE'] @ dev (alterantive for direct specification) - ['HALIKE'] @ ha - ['PRODLIKE'] @ prod - ['HALIKE', 'PRODLIKE'] @ perf This approach enables any number of copies or versions of deploymentTarget to be deployed or updated with identical or slightly varied configuration. Additionally as the governance process is version aware, multiple versions of the Service / Application / Component can co-exist in the same deploymentTarget Cyvive.io provides this default set of Template Technology Descriptors not to enforce direction on organisations but to assist with rapid adoption and integration with existing processes. The default Templates cover all operatingEnvironment types that an organization would utilize in developing and promoting an Application / Service / Component through its Continuous Delivery / Deployment lifecycle. While isolating and adding the infrastructure complexities step by step to assist with narrowing debugging focus. When creating a deploymentTarget Cyvive.io will deploy in parallel constrained by priority order all Services / Applications / Components relying on the container orchestration technology to confirm that each Service / Application / Component has started correctly. Should a service fail to start the failure will be reported back, otherwise a sucess response will be recieved.","title":"Default Template Names"},{"location":"governance/configuration/templates/#root-structure","text":"dev: ha: perf: prod: mandatory: (others) As mentioned previously any custom name can be used for a template except mandatory as its a reserved operatingEnvironment : All information populated in this key will be deployed into all deploymentTarget 's Should mandatory be used, it follows the same structure as Cyvive.io 's Service / Application / Component with the exception of groups as the mandatory key replaces the group key. As such the dedicated group configuration is also unavailable for mandatory","title":"Root Structure"},{"location":"governance/configuration/templates/#template-technology-descriptor","text":"Note '\u21db' character is used throughout this documentation where items are mandatory with respect to the parent YAML key. If not specified, then item is optional. example: environment: {} \u21db operatingEnvironment: [] resource: {}","title":"Template Technology Descriptor"},{"location":"governance/configuration/templates/#environment","text":"\u2026 structural copy of Service / Application / Component Environment","title":"environment"},{"location":"governance/configuration/templates/#operatingenvironment","text":"dev: \u21db operatingEnvironment: \u21db [] template type selection is controlled via the operatingEnvironment field. The following states select the operatingEnvironment : - [] @ dev (default) - ['DEVLIKE'] @ dev (alterantive for direct specification) - ['HALIKE'] @ ha - ['PRODLIKE'] @ prod - ['HALIKE', 'PRODLIKE'] @ perf","title":"operatingEnvironment"},{"location":"governance/configuration/templates/#resource","text":"\u2026 structural copy of Service / Application / Component Resource","title":"resource"},{"location":"governance/endpoints/","text":"Overview Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Summary Understanding how Cyvive.io 's exposed (behind a security layer) API's operate and expected results when interacting with them. Resoning Security and the ability to easily integrate with the existing enterprise technology stack is paramount to success for long-term adoption of any product. As Cyvive.io is dircetly interacting with the underlying container orchestration plaform, its essential that Cyvive.io 's security levels are as strong as what would be used in the cluster or higher. All REST API's are protected by MultiFactorAuthentication This section provides detailed information on each of the available REST API's, their requirements, returned values and expected results of what will occur in the cluster.","title":"Overview"},{"location":"governance/endpoints/#overview","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Summary Understanding how Cyvive.io 's exposed (behind a security layer) API's operate and expected results when interacting with them.","title":"Overview"},{"location":"governance/endpoints/#resoning","text":"Security and the ability to easily integrate with the existing enterprise technology stack is paramount to success for long-term adoption of any product. As Cyvive.io is dircetly interacting with the underlying container orchestration plaform, its essential that Cyvive.io 's security levels are as strong as what would be used in the cluster or higher. All REST API's are protected by MultiFactorAuthentication This section provides detailed information on each of the available REST API's, their requirements, returned values and expected results of what will occur in the cluster.","title":"Resoning"},{"location":"governance/endpoints/flow/","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. flow/ POST: (GitHub New Branch Event) 201 - :branch === namespace to create GET: all namespaces tracked by Cyvive.io DELETE: (GitHub Branch Delete Events)","title":"Flow"},{"location":"governance/endpoints/ingest/","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. ingest POST: (GitHub Push Events - matches to tracked apps / dumps if not tracked)","title":"Ingest"},{"location":"governance/endpoints/keys/","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. security/ //Key management for group decryption POST GET PATCH DELETE","title":"Keys"},{"location":"governance/endpoints/namespace/","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. /namespace (manual interactions) POST: create any from template + register with flow GET: /all /manual /flow (managed vs automated) DELETE: kubectl --delete namespace wrapper + deregister with flow","title":"Namespace"},{"location":"governance/endpoints/release/","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate.","title":"Release"},{"location":"governance/endpoints/tracker/","text":"Tracker Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Summary Auto-management of application infrastructure requirements and container change tracking REST Routes Note structure: {{TYPE}} {{ROUTE}} {{JSON BODY}} Tracker Names follow the format: group.name DELETE /trackers/{{group}}.{{name}} GET /trackers/ {} ~ returns all active trackers. For security reasons, this does not container the OAUTH tokens used for GitHub access GET /trackers/{{group}}.{{name}} {} ~ returns a specific tracker by name POST /trackers/ PUT /trackers/{{group}}.{{name}} { id: 'string', token: 'string', repo: 'string', sourcePath: 'string', tag: 'string' ~ optional branch: 'string' ~ optional commit: 'string' ~ optional } Enabling Any of the deployment patterns can be used to enable tracking functionality. The general approach is to start with a vanilla cluster, and enable tracking for each application to be managed by Cyvive.io . By sending a POST request. When tracking is enabled Cyvive.io will injest the cyvive.yaml file in the GitHub repository and configure accordingly. Approach Once the application has been added to tracker one of several scenarios can occur: cyvive.yaml in application's GitHub repo is modified. Application container is updated New Version of Application container is created In scenario 1, Cyvive.io will que the configuration changes until scenario 2 or 3 occur. This guarantees that updated infrastructure requirements are not applied to non-prepped containers. In scenario 2 or 3 Cyvive.io will add to dev release que. Preferred Versioning Container labels, can be either fixed or follow SemVer standards. Tracking module polls both GitHub Container Image Repository for changes / updates to images via API hashes (container images are not downloaded)","title":"Tracker"},{"location":"governance/endpoints/tracker/#tracker","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Summary Auto-management of application infrastructure requirements and container change tracking","title":"Tracker"},{"location":"governance/endpoints/tracker/#rest-routes","text":"Note structure: {{TYPE}} {{ROUTE}} {{JSON BODY}} Tracker Names follow the format: group.name DELETE /trackers/{{group}}.{{name}} GET /trackers/ {} ~ returns all active trackers. For security reasons, this does not container the OAUTH tokens used for GitHub access GET /trackers/{{group}}.{{name}} {} ~ returns a specific tracker by name POST /trackers/ PUT /trackers/{{group}}.{{name}} { id: 'string', token: 'string', repo: 'string', sourcePath: 'string', tag: 'string' ~ optional branch: 'string' ~ optional commit: 'string' ~ optional }","title":"REST Routes"},{"location":"governance/endpoints/tracker/#enabling","text":"Any of the deployment patterns can be used to enable tracking functionality. The general approach is to start with a vanilla cluster, and enable tracking for each application to be managed by Cyvive.io . By sending a POST request. When tracking is enabled Cyvive.io will injest the cyvive.yaml file in the GitHub repository and configure accordingly.","title":"Enabling"},{"location":"governance/endpoints/tracker/#approach","text":"Once the application has been added to tracker one of several scenarios can occur: cyvive.yaml in application's GitHub repo is modified. Application container is updated New Version of Application container is created In scenario 1, Cyvive.io will que the configuration changes until scenario 2 or 3 occur. This guarantees that updated infrastructure requirements are not applied to non-prepped containers. In scenario 2 or 3 Cyvive.io will add to dev release que.","title":"Approach"},{"location":"governance/endpoints/tracker/#preferred-versioning","text":"Container labels, can be either fixed or follow SemVer standards. Tracking module polls both GitHub Container Image Repository for changes / updates to images via API hashes (container images are not downloaded)","title":"Preferred Versioning"},{"location":"governance/extending/plugins/","text":"Extending with custom Plugins Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Summary integrating with the core Cyvive.io functionalities for custom gain. Architecturally Cyvive.io provides a series of custom events and actions that can be called as part of the core functionality. These are supported endpoints and are stable datastrutures that can be hooked into for any plugin development. These endpoints can also handle middleware, should the need arise. Events core events emitted regularly are as follows: generated:app generated:group generated:namespace updated:github updated:container configSync:check configSync:update isReady regenerate:app regenerate:group regenerate:ns refresh:generated refresh:db initDB","title":"Extending with custom Plugins"},{"location":"governance/extending/plugins/#extending-with-custom-plugins","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Summary integrating with the core Cyvive.io functionalities for custom gain. Architecturally Cyvive.io provides a series of custom events and actions that can be called as part of the core functionality. These are supported endpoints and are stable datastrutures that can be hooked into for any plugin development. These endpoints can also handle middleware, should the need arise.","title":"Extending with custom Plugins"},{"location":"governance/extending/plugins/#events","text":"core events emitted regularly are as follows: generated:app generated:group generated:namespace updated:github updated:container configSync:check configSync:update isReady regenerate:app regenerate:group regenerate:ns refresh:generated refresh:db initDB","title":"Events"},{"location":"governance/usage/developer/","text":"QuickStart: Usage for Developers Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Governance Overview Cyvive.io is a Layer 4 - 7 OSIMM Compliant and as such implements a Governance via Policy approach through YAML configuration files created per application / service / component. The language used in configuration description is not arbritary, and is the culmination of 35 respected academic and industry studies with containerization viewpoint spanning from MicroServices Architecture through to Enteprise Architecture principles. The configuration approach is powerful enough to handle governance of any type of application in the modern technology stack including 'cloud functions' while being flexible enough to be used in ordinary conversation between teams, departments and vendors. A detailed explanation of the configuration options is available Enabling Governance of your Service / Application / Component \u2026 is accomplished via a POST call to Cyvive.io . If running via the provided 'httpie' container http POST cyvive:3000/data technologyDescriptor:= { exampleGroup : { exampleApp : { version : v1.8.x }}} YAML as a string can also be provided if required under the technologyDescriptorYAML parameter Governance assets are automatically versioned based on the version parameter Deploying a Governed Service / Application / Component \u2026 is also done via POST call. If running via the provided 'httpie' container http POST cyvive:3000/namespace deploymentTarget=development require:= [ exampleApp.exampleGroup/ ] template=dev Briefly expanding the parameters: deploymentTarget is the namespace / environment that Cyvive.io should create or update require albiet an optional field will be used frequently by all developers. It provides the root of the governed dependency tree(s) to be deployed. As Cyvive.io is Layer 7 compliant each require is a Uniform Resource Identifier (URI) template is a higher level Governance Technology Descriptor. At its core separated into 4 logicical types (development ( dev ) = high availability ( ha ) = performance ( perf ) = production ( production )) with the default names provided in bold. Any number of template (s) can be created with custom names for each as long as they map to one of the core types for enabling / disabling elevated functionality. Additional information is available Removing a deploymentTarget \u2026 accomplished via standard DELETE call. If running via the provided 'httpie' container http DELETE cyvive:3000/namespace/development Purging a Service / Application / Component from Governance \u2026 accomplished via standard DELETE call. If running via the provided 'httpie' container http DELETE cyvive:3000/data/exampleGroup.exampleApp This will not actively purge any deployed assets in targets, just this asset from Governance and by defacto future deployments. Additional Reading / Information QuickStart: Govenor Cyvive.io Configuration Cyvive.io Endpoints Single Application / Service Example Multiple Application / Service Example {migrating} Dependecy Application / Service Example {migrating}","title":"Developer"},{"location":"governance/usage/developer/#quickstart-usage-for-developers","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate.","title":"QuickStart: Usage for Developers"},{"location":"governance/usage/developer/#governance-overview","text":"Cyvive.io is a Layer 4 - 7 OSIMM Compliant and as such implements a Governance via Policy approach through YAML configuration files created per application / service / component. The language used in configuration description is not arbritary, and is the culmination of 35 respected academic and industry studies with containerization viewpoint spanning from MicroServices Architecture through to Enteprise Architecture principles. The configuration approach is powerful enough to handle governance of any type of application in the modern technology stack including 'cloud functions' while being flexible enough to be used in ordinary conversation between teams, departments and vendors. A detailed explanation of the configuration options is available","title":"Governance Overview"},{"location":"governance/usage/developer/#enabling-governance-of-your-service-application-component","text":"\u2026 is accomplished via a POST call to Cyvive.io . If running via the provided 'httpie' container http POST cyvive:3000/data technologyDescriptor:= { exampleGroup : { exampleApp : { version : v1.8.x }}} YAML as a string can also be provided if required under the technologyDescriptorYAML parameter Governance assets are automatically versioned based on the version parameter","title":"Enabling Governance of your Service / Application / Component"},{"location":"governance/usage/developer/#deploying-a-governed-service-application-component","text":"\u2026 is also done via POST call. If running via the provided 'httpie' container http POST cyvive:3000/namespace deploymentTarget=development require:= [ exampleApp.exampleGroup/ ] template=dev Briefly expanding the parameters: deploymentTarget is the namespace / environment that Cyvive.io should create or update require albiet an optional field will be used frequently by all developers. It provides the root of the governed dependency tree(s) to be deployed. As Cyvive.io is Layer 7 compliant each require is a Uniform Resource Identifier (URI) template is a higher level Governance Technology Descriptor. At its core separated into 4 logicical types (development ( dev ) = high availability ( ha ) = performance ( perf ) = production ( production )) with the default names provided in bold. Any number of template (s) can be created with custom names for each as long as they map to one of the core types for enabling / disabling elevated functionality. Additional information is available","title":"Deploying a Governed Service / Application / Component"},{"location":"governance/usage/developer/#removing-a-deploymenttarget","text":"\u2026 accomplished via standard DELETE call. If running via the provided 'httpie' container http DELETE cyvive:3000/namespace/development","title":"Removing a deploymentTarget"},{"location":"governance/usage/developer/#purging-a-service-application-component-from-governance","text":"\u2026 accomplished via standard DELETE call. If running via the provided 'httpie' container http DELETE cyvive:3000/data/exampleGroup.exampleApp This will not actively purge any deployed assets in targets, just this asset from Governance and by defacto future deployments.","title":"Purging a Service / Application / Component from Governance"},{"location":"governance/usage/developer/#additional-reading-information","text":"QuickStart: Govenor Cyvive.io Configuration Cyvive.io Endpoints Single Application / Service Example Multiple Application / Service Example {migrating} Dependecy Application / Service Example {migrating}","title":"Additional Reading / Information"},{"location":"governance/usage/govenor/","text":"QuickStart: Usage for Govenors Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate. Governance Overview Cyvive.io is a Layer 4 - 7 OSIMM Compliant and as such implements a Governance via Policy approach through YAML configuration files created per application / service / component. The language used in configuration description is not arbritary, and is the culmination of 35 respected academic and industry studies with containerization viewpoint spanning from MicroServices Architecture through to Enteprise Architecture principles. The configuration approach is powerful enough to handle governance of any type of application in the modern technology stack including 'cloud functions' while being flexible enough to be used in ordinary conversation between teams, departments and vendors. A detailed explanation of the configuration options is available Service / Application / Component Overview \u2026 is best described through the Usage for Developers quickstart. Governance Inheritence Tree \u2026 is a Don't Repeat Yourself ( DRY ) approach efficiently utilized in Service Oriented Infrastructure ( SOI ). As such configuration follows an inheritance path ovelaying prior configuration settings where necessary. Overrides: template \u21db group \u21db service / application / component The use of this inheritance model also allows a segregation of security concerns where naturally authorized individuals interact with the correct Governance layers for enterprise and whole company management of Services. Template Technology Descriptors \u2026 are logically grouped into four meta-categories, and while the individual template can have any name assigned to it, the template must belong to a meta-category. Where each meta-catagory is based on the following operatingEnvironment logical progression: development \u21db high availability development \u21db performance \u21db production Default Template Names dev (type: development ) - single container availability - minimum resource allocation - probes: - ready ha (type: high availability development ) - dual container availability - minimum resource allocation - probes: - ready perf (type: performance ) - dual container availability - maximum resource allocation - probes: - ready - health prod (type: production ) - high availability - horizonal autoscaling - maximum resource allocation - probes: - ready - health template type selection is controlled via the type field. The following states select the operatingEnvironment : - [] @ dev (default) - ['DEVLIKE'] @ dev (alterantive for direct specification) - ['HALIKE'] @ ha - ['PRODLIKE'] @ prod - ['HALIKE', 'PRODLIKE'] @ perf Additional information on the template Technology Descriptors is available Adding a Template Technology Descriptor \u2026 accomplished via a standard POST call. If running via the provided 'httpie' container http POST cyvive:3000/template technologyDescriptor:= { customName : {type: [ HADEV ]}} Removing a Template Technology Descriptor \u2026 accomplished via standard DELETE call. If running via the provided 'httpie' container http DELETE cyvive:3000/template/customName This will not remove any existing deploymentTarget 's that utilizing this template it will just remove the template from future deploymentTarget . Group Technology Descriptor \u2026 is available for all groups under governance. Where applicable identical specifications at the group level override the template level. Its not necessary for group information to be specified as a pre-requisite to adding a Service / Application / Component to a non-existent group. It is possible Service / Application / Component to inherit configuration information from the group level, thus allowing enhanced security over a traditional deployment model, where keys can be present in the application environment and unknown to developers with Service / Application / Component source code access. Additional information on the group Technology Descriptors is available Additional Reading / Information QuickStart: Developer Cyvive.io Configuration Cyvive.io Endpoints Single Application / Service Example Multiple Application / Service Example {migrating} Dependecy Application / Service Example {migrating}","title":"Govenor"},{"location":"governance/usage/govenor/#quickstart-usage-for-govenors","text":"Warning This functionality was originally offered by the parent company as a separate product Fathomable . It is undergoing consolidation into Cyvive 's core and is restricted to beta customers at this time. Please contact your account manager via live-chat should you wish to participate.","title":"QuickStart: Usage for Govenors"},{"location":"governance/usage/govenor/#governance-overview","text":"Cyvive.io is a Layer 4 - 7 OSIMM Compliant and as such implements a Governance via Policy approach through YAML configuration files created per application / service / component. The language used in configuration description is not arbritary, and is the culmination of 35 respected academic and industry studies with containerization viewpoint spanning from MicroServices Architecture through to Enteprise Architecture principles. The configuration approach is powerful enough to handle governance of any type of application in the modern technology stack including 'cloud functions' while being flexible enough to be used in ordinary conversation between teams, departments and vendors. A detailed explanation of the configuration options is available","title":"Governance Overview"},{"location":"governance/usage/govenor/#service-application-component-overview","text":"\u2026 is best described through the Usage for Developers quickstart.","title":"Service / Application / Component Overview"},{"location":"governance/usage/govenor/#governance-inheritence-tree","text":"\u2026 is a Don't Repeat Yourself ( DRY ) approach efficiently utilized in Service Oriented Infrastructure ( SOI ). As such configuration follows an inheritance path ovelaying prior configuration settings where necessary. Overrides: template \u21db group \u21db service / application / component The use of this inheritance model also allows a segregation of security concerns where naturally authorized individuals interact with the correct Governance layers for enterprise and whole company management of Services.","title":"Governance Inheritence Tree"},{"location":"governance/usage/govenor/#template-technology-descriptors","text":"\u2026 are logically grouped into four meta-categories, and while the individual template can have any name assigned to it, the template must belong to a meta-category. Where each meta-catagory is based on the following operatingEnvironment logical progression: development \u21db high availability development \u21db performance \u21db production","title":"Template Technology Descriptors"},{"location":"governance/usage/govenor/#default-template-names","text":"dev (type: development ) - single container availability - minimum resource allocation - probes: - ready ha (type: high availability development ) - dual container availability - minimum resource allocation - probes: - ready perf (type: performance ) - dual container availability - maximum resource allocation - probes: - ready - health prod (type: production ) - high availability - horizonal autoscaling - maximum resource allocation - probes: - ready - health template type selection is controlled via the type field. The following states select the operatingEnvironment : - [] @ dev (default) - ['DEVLIKE'] @ dev (alterantive for direct specification) - ['HALIKE'] @ ha - ['PRODLIKE'] @ prod - ['HALIKE', 'PRODLIKE'] @ perf Additional information on the template Technology Descriptors is available","title":"Default Template Names"},{"location":"governance/usage/govenor/#adding-a-template-technology-descriptor","text":"\u2026 accomplished via a standard POST call. If running via the provided 'httpie' container http POST cyvive:3000/template technologyDescriptor:= { customName : {type: [ HADEV ]}}","title":"Adding a Template Technology Descriptor"},{"location":"governance/usage/govenor/#removing-a-template-technology-descriptor","text":"\u2026 accomplished via standard DELETE call. If running via the provided 'httpie' container http DELETE cyvive:3000/template/customName This will not remove any existing deploymentTarget 's that utilizing this template it will just remove the template from future deploymentTarget .","title":"Removing a Template Technology Descriptor"},{"location":"governance/usage/govenor/#group-technology-descriptor","text":"\u2026 is available for all groups under governance. Where applicable identical specifications at the group level override the template level. Its not necessary for group information to be specified as a pre-requisite to adding a Service / Application / Component to a non-existent group. It is possible Service / Application / Component to inherit configuration information from the group level, thus allowing enhanced security over a traditional deployment model, where keys can be present in the application environment and unknown to developers with Service / Application / Component source code access. Additional information on the group Technology Descriptors is available","title":"Group Technology Descriptor"},{"location":"governance/usage/govenor/#additional-reading-information","text":"QuickStart: Developer Cyvive.io Configuration Cyvive.io Endpoints Single Application / Service Example Multiple Application / Service Example {migrating} Dependecy Application / Service Example {migrating}","title":"Additional Reading / Information"},{"location":"platform/","text":"","title":"Understanding"}]}